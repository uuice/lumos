<!-- Table of Contents Component -->
<table-of-contents class="group" id="toc-container">
  <!-- TOC entries will be dynamically generated here directly -->

  <!-- Active indicator -->
  <div
    id="active-indicator"
    class="-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"
    style="display: none"
  ></div>
</table-of-contents>

<script>
  $(document).ready(function () {
    'use strict'

    // TOC Configuration
    const TOC_CONFIG = {
      maxDepth: 3, // Maximum depth to show in TOC
      scrollOffset: 32, // Scroll offset for smooth scrolling
      scrollBehavior: 'smooth' // Scroll behavior
    }

    // TOC Class
    class TableOfContents {
      constructor() {
        this.tocContainer = $('#toc-container')
        this.tocWrapper = $('#toc-container') // 直接使用 table-of-contents 元素
        this.activeIndicator = $('#active-indicator')
        this.tocEntries = []
        this.headings = []
        this.sections = []
        this.activeStates = []
        this.observer = null
        this.anchorNavTarget = null
        this.isInitialized = false

        this.init()
      }

      init() {
        // Wait for content to be ready
        this.waitForContent()
      }

      waitForContent() {
        const proseElement = $('.prose')
        if (proseElement.length) {
          // If prose element exists, initialize immediately
          this.setupTOC()
        } else {
          // Wait for content to load
          $(document).on('DOMContentLoaded', () => {
            setTimeout(() => this.setupTOC(), 100)
          })
        }
      }

      setupTOC() {
        if (this.isInitialized) return

        this.collectHeadings()
        this.generateTOC()
        this.setupIntersectionObserver()
        this.bindEvents()
        this.updateActiveStates()

        this.isInitialized = true
      }

      collectHeadings() {
        // Find all headings in the content
        const headings = $('h1, h2, h3, h4, h5, h6').filter(function () {
          return $(this).closest('.prose').length > 0
        })

        if (headings.length === 0) return

        // Find minimum depth
        let minDepth = 10
        headings.each(function () {
          const depth = parseInt($(this).prop('tagName').substring(1))
          minDepth = Math.min(minDepth, depth)
        })

        // Process headings
        headings.each((index, element) => {
          const $heading = $(element)
          const depth = parseInt($heading.prop('tagName').substring(1))
          const text = $heading.text().trim()
          const id = $heading.attr('id') || this.generateId(text, index)

          // Ensure heading has an ID
          if (!$heading.attr('id')) {
            $heading.attr('id', id)
          }

          // Only include headings within max depth
          if (depth < minDepth + TOC_CONFIG.maxDepth) {
            this.headings.push({
              element: $heading[0],
              depth: depth,
              text: text,
              id: id,
              index: index
            })

            // Find the section (parent element)
            const section = $heading.parent()
            this.sections.push(section[0])
          }
        })
      }

      generateId(text, index) {
        // Generate a simple ID from text
        return 'heading-' + index + '-' + text.toLowerCase().replace(/[^a-z0-9]+/g, '-')
      }

      generateTOC() {
        if (this.headings.length === 0) return

        // 清空现有内容，但保留 active-indicator
        this.tocContainer.find('a').remove()

        const minDepth = Math.min(...this.headings.map((h) => h.depth))
        let heading1Count = 1

        this.headings.forEach((heading, index) => {
          const tocEntry = this.createTOCEntry(heading, minDepth, heading1Count)
          // 将目录项插入到 active-indicator 之前
          this.activeIndicator.before(tocEntry)
          this.tocEntries.push(tocEntry)
          this.activeStates.push(false)

          if (heading.depth === minDepth) {
            heading1Count++
          }
        })
      }

      createTOCEntry(heading, minDepth, heading1Count) {
        const depth = heading.depth
        const isFirstLevel = depth === minDepth
        const isSecondLevel = depth === minDepth + 1
        const isThirdLevel = depth === minDepth + 2

        let badgeContent = ''
        let badgeClass =
          'transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold'

        if (isFirstLevel) {
          badgeContent = heading1Count
          badgeClass += ' bg-[var(--toc-badge-bg)] text-[var(--btn-content)]'
        } else if (isSecondLevel) {
          badgeContent =
            '<div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>'
          badgeClass += ' ml-4'
        } else if (isThirdLevel) {
          badgeContent =
            '<div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>'
          badgeClass += ' ml-8'
        }

        const textClass = `transition text-sm ${isFirstLevel || isSecondLevel ? 'text-50' : 'text-30'}`

        return $(`
        <a href="#${heading.id}" class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2" data-index="${heading.index}">
          <div class="${badgeClass}">
            ${badgeContent}
          </div>
          <div class="${textClass}">${this.removeTrailingHash(heading.text)}</div>
        </a>
      `)
      }

      removeTrailingHash(text) {
        const lastIndexOfHash = text.lastIndexOf('#')
        if (lastIndexOfHash !== text.length - 1) {
          return text
        }
        return text.substring(0, lastIndexOfHash)
      }

      setupIntersectionObserver() {
        // 无论是否支持 IntersectionObserver，都设置滚动事件作为备份
        this.setupScrollFallback()

        // 如果支持 IntersectionObserver，则使用它
        if (window.IntersectionObserver) {
          this.observer = new IntersectionObserver((entries) => this.handleIntersection(entries), {
            rootMargin: '-10% 0px -80% 0px'
          })

          // 观察所有标题元素
          this.headings.forEach((heading) => {
            this.observer.observe(heading.element)
          })
        }
      }

      handleIntersection(entries) {
        entries.forEach((entry) => {
          const heading = entry.target.querySelector('h1, h2, h3, h4, h5, h6')
          if (heading) {
            const id = heading.getAttribute('id')
            const index = this.headings.findIndex((h) => h.id === id)
            if (index !== -1) {
              this.activeStates[index] = entry.isIntersecting

              if (entry.isIntersecting && this.anchorNavTarget === heading) {
                this.anchorNavTarget = null
              }
            }
          }
        })

        if (!this.activeStates.includes(true)) {
          this.fallback()
        }

        this.updateActiveStates()
      }

      setupScrollFallback() {
        // Fallback for browsers without Intersection Observer
        $(window).on('scroll', () => {
          console.log('scroll')
          this.fallback()
          this.updateActiveStates()
        })
      }

      fallback() {
        if (this.headings.length === 0) return

        for (let i = 0; i < this.headings.length; i++) {
          const rect = this.headings[i].element.getBoundingClientRect()
          const offsetTop = rect.top
          const offsetBottom = rect.bottom

          if (
            this.isInRange(offsetTop, 0, window.innerHeight) ||
            this.isInRange(offsetBottom, 0, window.innerHeight) ||
            (offsetTop < 0 && offsetBottom > window.innerHeight)
          ) {
            this.activeStates[i] = true
          } else if (offsetTop > window.innerHeight) {
            break
          } else {
            this.activeStates[i] = false
          }
        }
      }

      isInRange(value, min, max) {
        return min < value && value < max
      }

      updateActiveStates() {
        requestAnimationFrame(() => {
          this.toggleActiveHeading()
          this.scrollToActiveHeading()
        })
      }

      toggleActiveHeading() {
        let i = this.activeStates.length - 1
        let min = this.activeStates.length - 1,
          max = 0

        // Remove visible class from all entries
        this.tocEntries.forEach((entry) => {
          entry.removeClass('visible')
        })

        // Find active range
        while (i >= 0 && !this.activeStates[i]) {
          i--
        }

        while (i >= 0 && this.activeStates[i]) {
          this.tocEntries[i].addClass('visible')
          min = Math.min(min, i)
          max = Math.max(max, i)
          i--
        }

        // Update active indicator position
        this.updateActiveIndicator(min, max)
      }

      updateActiveIndicator(min, max) {
        if (min >= this.activeStates.length || max < 0) {
          this.activeIndicator.hide()
          return
        }

        // 只使用当前激活的标题（min）
        const activeEntry = this.tocEntries[min]

        if (activeEntry && activeEntry.length) {
          // 添加相对定位类到容器
          this.tocContainer.addClass('relative')

          // 计算指示器位置和高度
          const entryRect = activeEntry[0].getBoundingClientRect()
          const containerRect = this.tocContainer[0].getBoundingClientRect()

          const top = entryRect.top - containerRect.top
          const height = entryRect.height

          this.activeIndicator.css({
            top: top + 'px',
            height: height + 'px',
            display: 'block'
          })
        } else {
          this.activeIndicator.hide()
        }
      }

      scrollToActiveHeading() {
        if (this.anchorNavTarget || !this.tocContainer.length) return

        const visibleEntries = this.tocContainer.find('a.visible')
        if (visibleEntries.length === 0) return

        const topmost = visibleEntries.first()
        const bottommost = visibleEntries.last()
        const tocHeight = this.tocContainer.height()

        let scrollTop
        const topmostBottom = topmost.offset().top + topmost.outerHeight()
        const bottommostTop = bottommost.offset().top

        if (bottommostTop - topmost.offset().top < 0.9 * tocHeight) {
          scrollTop = topmost.offset().top - TOC_CONFIG.scrollOffset
        } else {
          scrollTop = bottommost.offset().top - tocHeight * 0.8
        }

        this.tocContainer.animate(
          {
            scrollTop: scrollTop
          },
          {
            duration: 300,
            easing: 'swing'
          }
        )
      }

      bindEvents() {
        // Handle anchor clicks
        this.tocContainer.on('click', 'a[href^="#"]', (e) => {
          e.preventDefault()
          const href = $(e.currentTarget).attr('href')
          const id = decodeURIComponent(href.substring(1))
          const index = this.headings.findIndex((h) => h.id === id)

          if (index !== -1) {
            this.anchorNavTarget = this.headings[index].element
          } else {
            this.anchorNavTarget = null
          }

          // Smooth scroll to heading
          const targetElement = $(href)
          if (targetElement.length) {
            $('html, body').animate(
              {
                scrollTop: targetElement.offset().top - 100
              },
              {
                duration: 500,
                easing: 'swing'
              }
            )
          }
        })
      }

      destroy() {
        if (this.observer) {
          this.observer.disconnect()
        }

        $(window).off('scroll')
        this.tocContainer.off('click')
      }
    }

    // Initialize TOC when document is ready
    let tocInstance = null

    // Wait for content to be fully loaded
    $(window).on('load', function () {
      setTimeout(() => {
        if (!tocInstance) {
          tocInstance = new TableOfContents()
        }
      }, 200)
    })

    // Also try to initialize on DOM ready
    if (document.readyState === 'loading') {
      $(document).on('DOMContentLoaded', function () {
        if (!tocInstance) {
          tocInstance = new TableOfContents()
        }
      })
    } else {
      // Document is already ready
      if (!tocInstance) {
        tocInstance = new TableOfContents()
      }
    }
  })
</script>
